function N(r,e=[]){return(...t)=>(n=>n.length>=r.length?r(...n):N(r,n))([...e,...t])}const b=Array.isArray;function O(r,e,t){if(!b(t))throw new TypeError("reduce: list must be array or iterable");let n=0;const u=t.length;for(;n<u;)e=r(e,t[n],n,t),n++;return e}const R=N(O);function S(r){const e=typeof r;if(r===null)return"Null";if(r===void 0)return"Undefined";if(e==="boolean")return"Boolean";if(e==="number")return Number.isNaN(r)?"NaN":"Number";if(e==="string")return"String";if(b(r))return"Array";if(e==="symbol")return"Symbol";if(r instanceof RegExp)return"RegExp";const t=r&&r.toString?r.toString():"";return["true","false"].includes(t)?"Boolean":Number.isNaN(Number(t))?t.startsWith("async")?"Async":t==="[object Promise]"?"Promise":e==="function"?"Function":r instanceof String?"String":"Object":"Number"}function h(r){const e=r.__proto__.toString();return["Error","TypeError"].includes(e)?[e,r.message]:[]}function d(r){return r.toDateString?[!0,r.getTime()]:[!1]}function E(r){return r.constructor!==RegExp?[!1]:[!0,r.toString()]}function g(r,e){if(arguments.length===1)return o=>g(r,o);const t=S(r);if(t!==S(e))return!1;if(t==="Function")return r.name===void 0?!1:r.name===e.name;if(["NaN","Undefined","Null"].includes(t))return!0;if(t==="Number")return Object.is(-0,r)!==Object.is(-0,e)?!1:r.toString()===e.toString();if(["String","Boolean"].includes(t))return r.toString()===e.toString();if(t==="Array"){const o=Array.from(r),i=Array.from(e);if(o.toString()!==i.toString())return!1;let f=!0;return o.forEach((c,a)=>{f&&c!==i[a]&&!g(c,i[a])&&(f=!1)}),f}const n=E(r),u=E(e);if(n[0])return u[0]?n[1]===u[1]:!1;if(u[0])return!1;const l=d(r),s=d(e);if(l[0])return s[0]?l[1]===s[1]:!1;if(s[0])return!1;const m=h(r),y=h(e);if(m[0])return y[0]?m[0]===y[0]&&m[1]===y[1]:!1;if(t==="Object"){const o=Object.keys(r);if(o.length!==Object.keys(e).length)return!1;let i=!0;return o.forEach(f=>{if(i){const c=r[f],a=e[f];c!==a&&!g(c,a)&&(i=!1)}}),i}return!1}function w(r){return r}function p(r,e){return arguments.length===1?t=>p(r,t):r*e}const x=R(p,1);function A(r,e){if(arguments.length===1)return u=>A(r,u);if(Number.isNaN(Number(r))||Number.isNaN(Number(e)))throw new TypeError("Both arguments to range must be numbers");if(e<r)return[];const t=e-r,n=Array(t);for(let u=0;u<t;u++)n[u]=r+u;return n}function j(r,e){return arguments.length===1?n=>j(r,n):e.slice().sort((n,u)=>{const l=r(n),s=r(u);return l===s?0:l<s?-1:1})}export{g as e,w as i,A as r,j as s};
